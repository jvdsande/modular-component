# ModularComponent

**🍞.with(🍅).with(🧀) = 🥪**

> Delightfully organized and deeply testable React Components

## What are Modular Components

Modular Components are React components built through a modular factory, allowing the
addition of functionality as needed as the component is built.

The modular factory approach is built on top of React hooks, and offers out-of-the-box
composition for building and stub injections for testing.

It offers best-in-class DX through strong typing and easy separation of concern, and is
infinitely extensible thanks to its built-in modular nature.

You can think of it as "higher-order hooks", without the awkward chaining of methods
thanks to the factory pattern.

## Documentation

Find our complete documentation on [modularcomponent.dev](https://modularcomponent.dev).

## Installation

At it simplest, you will need the `@modular-component/core` package to get started with `ModularComponent`.

However, the core module alone does not bring any component capability - it needs plugins,
or extensions, to start shining ✨

We provide a sensible set of default capabilities through the `@modular-component/default` package.
It is highly recommended to install both for getting started.

```sh
yarn add @modular-component/core @modular-component/default
```

You can then build your component factory by combining the `modularFactory` export from
`@modular-component/core`, and the default set of stages exported as `WithDefaultStages`
from `@modular-component/default`.

```tsx
import { modularFactory } from '@modular-component/core'
import { WithDefaultStages } from '@modular-component/default'

const ModularComponent = modularFactory.extend(WithDefaultStages).build()
```

You can then instantiate new components with the `ModularComponent` factory function:

```tsx
const MyFirstModularComponent = ModularComponent<{
  someFlag?: boolean
  someLabel: string
  someValue: number
}>()
  .withDefaultProps({ someFlag: false })
  .withLifecycle(({ props }) => {
    const [someState, setSomeState] = useState(0)

    return { someState }
  })
  .withRender(({ props, lifecycle }) => (
    <>
      <h2>
        {props.someLabel}: {props.someValue}
      </h2>
      <p>Value from state: {lifecycle.someState}</p>
      <p>Flag from props: {props.someFlag ? 'true' : 'false'}</p>
    </>
  ))
```

## How it works

### The factory pipeline

#### Pipeline stages

The main concept behind the `ModularComponent` approach is the factory pipeline.

At its core, a `ModularComponent` is a set of ordered **stages**, each of which populates
a specific **argument** in a shared object, which gets passed from stage to stage.

The last stage (usually, but not necessarily, the **render stage**) has therefore access
to data computed by every previous stage in the pipeline.

This for instance allows separating any stateful lifecycle computation in a dedicated
stage, and keep the render stage for its main purpose: laying down the markup through JSX.

Here is the "getting started" example, complete with comments explaining
the pipeline system:

```tsx
import { ModularComponent } from '@modular-component/core'

const MyFirstModularComponent = ModularComponent<{
  someFlag?: boolean
  someLabel: string
  someValue: number
}>()
  // .withDefaultProps modifies the `props` argument to mark
  // provided props as NonNullable. Here, `someFlag` will be
  // a `boolean` for all further stages, instead of `boolean | undefined`
  // as it originally was
  .withDefaultProps({ someFlag: false })
  // .withLifecycle receives the modified props from .withDefaultProps
  // It then uses React hooks to construct our component's internal state
  .withLifecycle(({ props }) => {
    const [someState, setSomeState] = useState(0)

    return { someState }
  })
  // Finally, .withRender receives both the up-to-date props and the new
  // lifecycle argument generated by the .withLifecycle stage
  .withRender(({ props, lifecycle }) => (
    <>
      <h2>
        {props.someLabel}: {props.someValue}
      </h2>
      <p>Value from state: {lifecycle.someState}</p>
      <p>Flag from props: {props.someFlag ? 'true' : 'false'}</p>
    </>
  ))
```

#### Adding stages

Internally, a `ModularComponent` keeps an array of ordered stages. Calling a stage
method will either append a new stage to the array, or edit an already existing value.

There are two main stage methods for each available stage type:

- The `with{Stage}` method, as seen is the getting started example, _upsert_ a stage into the array.

  Calling it one time will append the stage at the end of the array; subsequent calls to the same
  stage method will replace the implementation of the stage but keep its position in the pipeline.

  Because of this, it's important that the provided value honors the contract set up by the very
  first call, otherwise it could break downstream stages depending on it.

  When using TypeScript, this is enforced internally, and subsequent calls to an already added stage
  will be narrowed to force honoring previous contracts.

- The `add{Stage}` method _appends_ a new stage into the array.
  It can only be called after the `with` method of the same stage has been used at least once.

  When calling this method, a new stage of the same type is added at the end of the pipeline,
  leaving the previous stages untouched. The argument generated by the newly added stage will
  only be available to downstream stages, and upstream stages will keep receiving the value
  generated by the previous stage of the type.

  Since previous stages are not modified, `add` calls can completely change the value of
  the field without any impact on upstream stages. For the same reason, the TypeScript definition
  is not restricted.

  When calling a `with` method when multiple stages of the same type have been added through `add`,
  the last stage of the type is edited. It's also possible to pass an optional index
  to edit previous stages instead.

#### Manipulating stages

We've seen how the `with` and `add` stage methods allow us to append or edit stages
in our component's pipeline. Additionally, we can further manipulate our pipeline through
three additional stage methods: `at`, `before` and `mock`.

- `at{Stage}` stage methods rewind the pipeline to the given stage. If multiple stages of the
  same type were added through the `add` method, the pipeline is rewound to the last stage of the type.
  An optional index can also be provided to rewind to a specific occurrence. All downstream
  stages are dropped, while all upstream stages are kept as-is.
- `before{Stage}` stage methods work the same as `at{Stage}` methods, but do not include the
  target stage, as the name implies. This can be useful for instance when wanting to replace
  a render stage, but wanting to add some additional stages before.
- `mock{Stage}` stage methods replace the value generated by a given stage, skipping any transform
  configured for the stage (see [Extension](#the-extension-system) below).

Combining those methods is especially powerful when testing stages in isolation: `at` allows
dropping downstream stages, while `mock` allows stubbing and controlling upstream stages, leaving
the currently tested stage isolated in the pipeline.

### The extension system

`ModularComponent` aims to be a toolkit, and as such, it needs to be as agnostic as possible
of the application context. For this reason, the core factory only implements a single stage: `withRender`,
which is in fact a simple, traditional React function component.

Capabilities can then be added on a per-application basis, to construct a pipeline that
makes sense for a specific application context: adding a stage for connecting to a global
store, or for handling internationalization...

Such capabilities are added through **extensions**. Extensions are configuration objects
detailing new stage methods to add to the factory.

> **Understanding stages**
>
> Each stage of a pipeline receives _exactly one argument_, that can be of any form.
>
> The received value is passed to an optional _transform function_ specific
> to each stage, and the resulting value from this call is added to the
> arguments map.
>
> When executed, each stage modifies _exactly one argument_ in the shared arguments map.

#### Setting a name and a target argument

In order to add a new stage, we need to provide at the very least:

- A unique symbol used to identify the stage type
- The base name of the stage to add to the factory (`Lifecycle`, `DefaultProps`...), which will be suffixed to the stage methods (`withLifecycle`, `addLifecycle`...)
- The name of the argument modified by the stage (`lifecycle`, `props`...)

Extensions are written as a map of stage name to method configuration. For instance, the `withLifecycle`
definition looks something like this:

```tsx
const withLifecycle = Symbol()

export const WithLifecycle = {
  Lifecycle: {
    symbol: withLifecycle,
    field: 'lifecycle',
    transform: () => {
      /* documented below */
    },
  },
} as const
```

You can add as many stage methods as you want. Different stage methods can also impact
the same field if needed, for some advanced cases.

#### Type-safe definition: the `createMethodRecord` helper

To ensure the configuration you produce is valid, you can wrap it in `createMethodRecord` exported
by `@modular-component/core`:

```tsx
import { createMethodRecord } from '@modular-component/core'

export const WithLifecycle = createMethodRecord({
  Lifecycle: {
    symbol: withLifecycle,
    field: 'lifecycle',
    transform: () => {
      /* documented below */
    },
  },
} as const)
```

Notice the `as const` statement, making sure TypeScript narrows all
types as much as possible. It is of paramount importance to always add this statement
to ensure type inference works correctly. Otherwise, the `field` parameter
could be inferred as `string`, polluting the complete arguments map, and
the `symbol` field would be inferred as a generic `symbol`, rather than
the unique symbol type.

If you provide a misconfigured method, the `createMethodRecord` function
will reject the argument, letting you know right away.

#### Transforming the argument before committing it to the map

At its simplest, a stage will simply append the provided value as-is to the argument
map, but it might not be sufficient for all cases.

For instance, our `Lifecycle` stage takes a hook as value, but should append _the result of this hook_
to the arguments map.

For this purpose, a stage can also receive a `transform` configuration parameter, detailing
how to generate the final value that will be added to the arguments map.

The `transform` function receives two parameters: the current arguments map received from
previous stages, and the value passed down to the stage by the user. It then returns the
transformed value to add to the arguments map:

```tsx
export const WithLifecycle = createMethodRecord({
  Lifecycle: {
    symbol: withLifecycle,
    field: 'lifecycle',
    transform: (args, useLifecycle) => {
      return useLifecycle(args)
    },
  },
} as const)
```

In addition to the stage value, the transform function also receives the arguments map computed
by upstream stages. In this case, the arguments map is passed as parameter to the lifecycle hook,
allowing it to react to props and other upstream stages.

Note how we also renamed the parameter to `useLifecycle`: as this can contain hook calls, we
need to name it accordingly to not break the rule of hooks here.

#### Telling TypeScript about a value transformation

Most of the time, the transformation that we apply on a value changes its type
from the one passed as parameter. Unfortunately, as of TypeScript 4.8, there isn't
a way still to use "generic generic types". It is therefore not possible, as far as we can tell,
to retrieve the type of the `transform` configuration and use it to infer the final type
of the argument.

The workaround implemented for now is an exposed interface, `ModularStages`, that
takes generic parameters and contains typing information for our stages. An extension package
can overload this interface to add the correct information for the provided stage.

In order to avoid clashes between multiple extensions providing a similar
stage function name, the typing map uses _symbols_ as its key to ensure
uniqueness. The symbol must be passed to the corresponding stage function definition.

In the case of our lifecycle stage, we saw that we created a `withLifecycle` symbol
and passed it to the stage configuration. We can use it to correctly type the transform,
which should extract the return type of the provided hook:

```tsx
// 👇 1. We create our unique symbol
const withLifecycle = Symbol()

export const WithLifecycle = createMethodRecord({
  Lifecycle: {
    symbol: withLifecycle, // 👈 2. We assign our symbol to our configuration
    field: 'lifecycle',
    transform: (args, useLifecycle) => {
      return useLifecycle(args)
    },
  },
} as const)

// 👇 3. We extend the ModularStages interface to add our typings
declare module '@modular-component/core' {
  // The current arguments are passed as generic parameter...
  //                              👇
  export interface ModularStages<Args, Value> {
    // ... along with the original value 👆

    [withLifecycle]: {
      // 👆 4. We use our symbol as index for our entry
      transform: Value extends (args: Args) => unknown
        ? ReturnType<Value> // 👈 5. We apply our type transformation,
        : // constraining the original value as needed
          never
    }
  }
}
```

With this, TypeScript will correctly infer the type of our lifecycle argument as the return
type of the provided hook!

#### Restricting the type of the passed value

Specifically for TypeScript users, stage method type definition allows defining a type
that the passed value should match to be considered valid. This information will be
surfaced to the user, marking the stage call as incorrect if the value type do not match
the expected restriction.

Continuing with our lifecycle hook, we want to restrict the value to a function receiving
the arguments map as parameter.

This is done through the `restrict` property:

```tsx
declare module '@modular-component/core' {
  export interface ModularStages<Args, Value> {
    [withLifecycle]: {
      // Restrict the accepted value as a function of current
      // arguments map  👇
      restrict: (args: Args) => unknown
      //                           👆
      // We don't want to restrict the form of the
      // returned value
      transform: Value extends (args: Args) => unknown
        ? ReturnType<Value>
        : never
    }
  }
}
```

> **Side note: `restrict: undefined`**
>
> Whenever `restrict: undefined` is used on a stage method, the type
> definition will allow users to omit the argument completely. Useful for
> stages that return a constant value or only execute side-effects!

### Generating hooks

Atop of the factory stages seen previously, `ModularComponent`s
also expose methods for converting our component to a hook:

- `asHook`: extract the stages as a custom hook, returning the map of arguments.
  This is used internally when calling the generated component, but can also be
  useful in other situations like tests, or the need to generate a shared hook
  consuming application context, such as a global store for which a stage exists.
- `asUse{Argument}`: creates a custom hook running our pipeline and returning the
  value of one specific argument. Useful in combination with `at{Stage}` to test
  the returned value of a given stage easily.

Combining those hook methods with `at` and `mock` stage methods can be very powerful in testing scenarios. For instance,
one can extract the lifecycle hook of a component by chaining them:

```tsx
const useLifecycle = MyComponent.atLifecycle().asUseLifecycle()
```

Or one could mock the lifecycle entirely to test the render:

```tsx
const OnlyRender = MyComponent.mockLifecycle({
  fromLifecycle: 'hello world',
})
```

## Official extensions

### `@modular-component/default`

Set of sensible defaults for using `ModularComponent`. Provides two stages:
`withLifecycle` for adding a lifecycle hook, and `withDefaultProps` for
providing default values for props.

It's also possible to import each of them individually through `@modular-component/with-lifecycle`
and `@modular-component/with-default-props` respectively.

### `@modular-component/with-components`

Provides a `withComponents` stage that fills the `components` argument with
a map of React components. Useful when running tests in an environment that
does not allow module mocking: sub-components can be stubbed in tests by
calling the stage again to replace their implementations.

### `@modular-component/with-conditional-render`

Provides three stages that allow conditional rendering in `ModularComponent`s:

- `withCondition` will set a `condition` argument to either `true` or `false`, based
  on current arguments,
- `withConditionalFallback` takes a `FunctionComponent` as parameter, and
  renders it when the `condition` argument is set to `false`,
- `withConditionalRender` also takes a `FunctionComponent` as parameter, and
  renders it when the `condition` argument is _not_ set to `false`.

Downstream condition stages and conditional fallback stages will respect the value
provided by upstream stages, allowing chaining multiple conditions with a different fallback for each.
Calls to `addCondition` will take into account preceding conditions, so that `withConditionalRender`
is only called when all conditions return `true`.
